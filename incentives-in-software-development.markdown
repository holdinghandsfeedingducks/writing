#Incentives and Barriers in Software Development & Design.

by Dominic Tarr (@dominictarr)

Computers have come one heck of a long way in the last 100 years, but one of the 
things that gets me is just how much room for improvement still remains.

If you have a job using computers, chances are that you hate it. Yes, there are 
those of us who love using computers, but there are just as many who loathe them. A computer can be a 
powerful creative tool, but unfortunately it can also be the opposite of that.

A computer system can railroad you into having to do things a particular way. 
If you can see a better way (which often, you can) this will be incredibly frustrating. Like being stuck in traffic. If things were different, you would be home by now.

It's not just a problem with computers, it's a problem with _design_. (I'm not talking about 
graphic design, I mean technical design - how things work). Largely the problem 
is bad user interfaces, but don't forget that there are also user interfaces on 
the inside.

The things you have to do to fix your car, what to crank up, what to unbolt, 
also constitute a user interface (just for a more advanced user).

This article is not about how to make good design, we already know how to make good 
design. It's wired into our tool-making monkey brains. What this article is 
about is why good design doesn't just happen. And maybe how it can start to happen.

The problem, unfortunately, is with the economics of designs.

A favourite example of mine is microwave user interfaces. Microwaves all do the 
same thing. Nearly every microwave user wants to do the same thing with their microwave. 
Heat stuff to eat. But microwaves nearly always have way TOO MANY BUTTONS.
I have a degree in computer science, but I often can't figure out how to work a microwave.

Ideally a microwave should have just one button: 'MAKE THIS HOT'. 
instead you get a Boeing-cockpit of unnecessary controls. _I'm only trying to make cheese on toast_. I do not need to be able to use 80% power for 3 minutes and 27 seconds, EVER.

So, microwave interfaces suck, we all know this. But why are they all like this, 
and why can't we fix them?

I'm not sure why microwaves have so many controls. It kinda made sense in the 
early days, when they were new and exciting, and people thought they'd use them 
to actually do cooking, not just heating stuff. You see a lot of microwave 
cookbooks in opportunity shops. Maybe a microwave with more features is 
easier to sell, because there is more things for the salesman to talk about.

Okay, so why can't we fix them? Well, I can see what needs to be done. But there 
is whats called a barrier to entry: I don't own a microwave company, work for 
one, or know anything else about microwaves. I just know how the interface needs 
to be.

This is a real problem. This causes microwave users seconds of annoyance 
every day. This might not seem like a big deal, but this is just one example.
The point is that bad usability, spread across many items, appliances, 
cell phones, software, websites, etc, all adds up to a big problem. 
It shortens lives, and makes people hate their jobs.

The barrier to entry to creating a better design is one obstacle for good design. 
Another barrier is about incentives.

For my second example I'll talk about software, because unlike kitchen appliances, 
there is another way some software is developed: open source. 

Open Source effectively gets around the barrier to entry problem, because there 
are no manufacturing costs for software. With software, you can go from a design 
(source code) to a usable application (binary) _automatically_. This is because 
there is a computer program (called a compiler), which can assemble the instructions 
for the machine directly from the instructions that a skilled human can give it. 
So if I give away a software design, anyone can replicate it for free, and also 
make changes to my design, and still turn it into working software for free.

This is not the case for physical devices yet. But if there were machines 
that could take a design for any kind of appliance, and build that custom 
appliance automatically, then open source appliances would be possible. 
(This technology is coming, and already there are machines which can produce 
arbitrary circuits, or print out solid 3D shapes - of course it's more expensive 
than compiling software, because it requires physical materials, but it's 
essentially the same thing only limited in scope.)

Open source, however, is only half the solution. The trouble with open source 
software is that it lacks incentive. Programmers must build and fix
things for their own use, for fun, or to develop their skills. Hence, open source 
produces a lot of programmer tools, and then stops. 

This is only a fraction of the things computers are used for, but there is little 
reason to fix end-user applications, because it's not worth the effort for the 
rewards: suppose there is a small problem with a piece of end-user open source 
software. Just something annoying, but it causes the user to waste 30 seconds 
of their day (of course, there will be bigger problems too, but if we can't 
solve small problems how can we solve big ones?). Now, 30 seconds a day becomes 
3 hours a year. Now suppose it may take 30 hours for a computer programmer to 
do everything they need to fix this problem (when you add up all the time it 
takes to get familiar with the workings of the software, to try different 
approaches, and test their solution). 30 hours is quite possible.

Now, if the programmer in this case is only fixing the problem for their own 
benefit, they would only start saving time after they have used the software for 
10 years! they probably won't be using that software in 10 years, 
so it's just not worth it.

But what if there are 1,000 people who use that software? In one year, 
3,000 hours have been wasted. If users of the software could give improvers of 
the software just $1 for each hour they have been saved, then suddenly it would 
be incredibly lucrative to fix problems like this. Programmers would compete to 
be the one to solve them! And then the problems would just seem to disappear.

Of course there are big problems as well, which naturally are worth a lot more. 
But either way, there are many problems which people can see solutions to, but 
can't afford to fix, because there is no way for the solutions value to get to 
them.

Things like the app store are a huge step in the right direction, because it 
dramatically reduces the barriers to distributing software. _But not by enough_.

What we need is a online marketplace for _software features_. Not just whole 
applications, but small changes to existing applications.

You need a button which says "I'm confused" and when you click on it the 
software gets more intuitive. You need to button for "I get this, okay" and 
you get a more advanced interface for more powerful users. If you don't like a 
particular widget, you can just get another.

The system would need to measure which solutions are better for which problems, 
and allow you to incentivise production of even better features.

Now, such a system doesn't exist yet, but when it does, it will unleash a goldrush for value that was previously unattainable.

The reasons good design isn't happening as often as it should is not because
we don't know what the designs should be, but rather, it's that our business
models are getting in the way. If we could lower barriers and raise incentives
we could fix everything.

The central challenge to such a system, is that you can't let just anyone mess 
with your designs. If "improvements" break things, then it will waste more time 
than it could have saved, and it will be better to just pick 
the devil you know, rather than a possible lesser of two evils.

Candidate improvements need to be _automatically tested_, so you know that the 
original application still works. Then they need to be distributed seamlessly,
and when something does break, that needs to be redacted just as seamlessly.

This is a hard problem, and as far as I know, this type of solution has not yet been attempted.

But I believe it is possible. In fact, I'm working on it ...
